/********************************************************************************
  * 文 件 名: UART.c
  * 版 本 号: 初版
  * 修改作者: Smoaflie
  * 修改日期: 2023年08月27日
  * 功能介绍: 配置及使用51单片机的UART功能         
  ******************************************************************************
  * 注意事项: 该代码遵守 GPL3.0开源协议，仅供学习参考，禁止商用
*********************************************************************************/

#include "UART.h"

static u8 xdata UART_RX_BUF[UART_MAX_RECV_LEN];	//存储接收数据 
static u16 UART_RX_STA = 0x0000;	//标志接收状态
static u8 UART_TX_FLAG = 0;	//标志发送状态

/************************************************
函数名称 	: 	UART_Init
功    能 	: 	初始化UART功能并设置波特率
参    数 	: 	baud_rate:波特率
返 回 值 	: 	无
*************************************************/
void UART_Init(u16 baud_rate)
{
	/* 配置串行口的通信方式 */
	SCON &= ~(0x01 << 7);
	SCON |= (0x01 << 6);
	REN = 1;	//开启串行接收
	
	/* 配置定时器1 */
	TMOD &= 0x0F;		//设置定时器模式
	TMOD |= 0x20;		//设置定时器模式

	/* 配置波特率 */
	PCON |= 0x80;		//使能波特率倍速位SMOD

	TL1 = TH1 = (256 - 57600/baud_rate);	//设置波特率

	/* 配置相关中断 */
	EA = 1;			//开启中断总线
	ET1 = 0;		//关闭定时器1中断
	
	IP |= 0X10;		//设置串行口中断为高优先级
	ES = 1;			//开启串行口中断
	
	/* 配置结束 */
	TR1 = 1;		//定时器1开始计时
}

/************************************************
函数名称 	: 	Timer0Init
功    能 	: 	初始化定时器0：16位模式，10ms@11.0592MHz
参    数 	: 	无
返 回 值 	: 	无
*************************************************/
void Timer0Init(void)
{
	/* 设置定时器模式 */
	TMOD &= 0xF0;	
	TMOD |= 0x01;	
	/* 设置超时时间 */
	TL0 = 0x00;		//设置定时初始值
	TH0 = 0xDC;		//设置定时初始值
	/* 配置定时器0中断 */
	PT0 = 1;		//设置高优先级
	ET0 = 1;		//定时器0中断开启
	
	TR0 = 0;		//关闭定时器0
}

/************************************************
函数名称 	: 	UART_SendByte
功    能 	: 	串口发送一个字节
参    数 	: 	ucch：字节
返 回 值 	: 	无
*************************************************/
void UART_SendByte(u8 ucch)
{
	SBUF = ucch;
	while(UART_TX_FLAG==0&&TI==0);
	UART_TX_FLAG=0;TI=0;
}

/************************************************
函数名称 	: 	UART_SendStr
功    能 	: 	串口发送字符串
参    数 	: 	ucstr：字符串
返 回 值 	: 	无
*************************************************/
void UART_SendStr(u8 *ucstr)
{
	while(ucstr && *ucstr)        // 地址为空或者值为空跳出
	{
		UART_SendByte(*ucstr++);
	}
}

/************************************************
函数名称 	: 	UART_Isr
功    能 	: 	串口中断服务函数
参    数 	: 	无
返 回 值 	: 	无
*************************************************/
void UART_Isr(void) interrupt 4 using 1
{
	//接收中断触发
	if(RI)
	{
		u8 Res;
		Res = SBUF;
		RI = 0;
		if((UART_RX_STA & (1<<15)) == 0)	//接收未完成
		{
			if(UART_RX_STA < UART_MAX_RECV_LEN)	//还可以接收数据
			{
				/* 重置超时时间 */
				TL0 = 0x00;		//设置定时初始值
				TH0 = 0xDC;		//设置定时初始值
				
				if(!UART_RX_STA)
				{
					TR0 = 1;	//打开定时器0
				}
				UART_RX_BUF[UART_RX_STA++] = Res;	//记录接收到的值
			}
			else
			{
				UART_RX_STA |=1<<15;	//强制标记接收完成
			}
		}
		//SBUF = Res;	//该语句是为了将AS608回应的数据呈现在电脑中，方便调试
	}
	
	if(TI)
	{
		TI = 0;
		UART_TX_FLAG = 1;//标志传输完成
	}
}

/************************************************
函数名称 	: 	on_timeout
功    能 	: 	(定时器0中断服务函数)等待时间超时处理函数
参    数 	: 	无
返 回 值 	: 	无
*************************************************/
void on_timeout(void) interrupt 1
{
	
	UART_RX_STA|=1<<15;	//标记接收完成
	TR0 = 0;		//关闭定时器0
	/* 重置超时时间 */
	TL0 = 0x00;		//设置定时初值
	TH0 = 0xDC;		//设置定时初值
	
	/* 将数据传给AS608函数判断 */
	AS608_JudgeData(UART_RX_BUF);
	
	/* 重置接收器 */
	UART_RX_STA = 0x00;
}
